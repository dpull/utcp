#include "utcp_handshake.h"
#include "bit_buffer.h"
#include "utcp.h"
#include "utcp_packet.h"
#include "utcp_sequence_number.h"
#include "utcp_utils.h"
#include <assert.h>
#include <string.h>

enum EHandshakePacketType
{
	EHandshakePacketType_InitialPacket = 0,
	EHandshakePacketType_Challenge = 1,
	EHandshakePacketType_Response = 2,
	EHandshakePacketType_Ack = 3,
	EHandshakePacketType_RestartHandshake = 4,
	EHandshakePacketType_RestartResponse = 5
};

enum
{
	MAX_PACKETID = SeqNumberCount,

	SessionIDSizeBits = 2,
	ClientIDSizeBits = 3,
};

enum
{
	/** The base amount of random data to add to handshake packets */
	BaseRandomDataLengthBytes = 16,

	/** The amount by which the length of random data should randomly vary */
	RandomDataLengthVarianceBytes = 8,

	/** HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Original */
	OriginalHandshakePacketSizeBits = 227,

	/** RESTART_HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Original */
	OriginalRestartHandshakePacketSizeBits = 2,

	/** RESTART_RESPONSE_SIZE_BITS for EHandshakeVersion::Original */
	OriginalRestartResponseSizeBits = 387,

	/** HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Randomized */
	VerRandomizedHandshakePacketSizeBits = 259,

	/** RESTART_HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Randomized */
	VerRandomizedRestartHandshakePacketSizeBits = 34,

	/** RESTART_RESPONSE_SIZE_BITS for EHandshakeVersion::Randomized */
	VerRandomizedRestartResponseSizeBits = 419,
};

enum utcp_challenge_state
{
	UnInitialized,		// HandlerComponent not yet initialized
	InitializedOnLocal, // Initialized on local instance
	InitializeOnRemote, // Initialized on remote instance, not on local instance
	Initialized			// Initialized on both local and remote instances
};

enum EHandshakeVersion
{
	EHandshakeVersion_Original = 0,		// The original/unversioned handshake protocol
	EHandshakeVersion_Randomized = 1,	// The version of the handshake protocol with randomization, versioning and debug/diagnostic tweaks
	EHandshakeVersion_NetCLVersion = 2, // Added Network CL version, for optional extra-early client rejection

	/** Net compatibility break */

	EHandshakeVersion_SessionClientId = 3, // Added SessionId (index of server game session) and ClientId (clientside index of NetConnection)

	EHandshakeVersion_Latest = EHandshakeVersion_SessionClientId
};

static uint8_t CurrentHandshakeVersionVar = EHandshakeVersion_Latest;
static uint8_t LastRemoteHandshakeVersionVar = EHandshakeVersion_Latest;
static uint8_t MinSupportedHandshakeVersionVar = EHandshakeVersion_SessionClientId;

struct FParsedHandshakeData
{
	/** The minimum supported handshake protocol version of the remote side */
	uint8_t RemoteMinVersion;

	/** The current handshake protocol version the remote side used for communication */
	uint8_t RemoteCurVersion;

	/** The Network CL version of the remote side */
	uint32_t RemoteNetworkVersion;

	/** The type of handshake packet */
	uint8_t HandshakePacketType;

	/** The remote value of 'SentHandshakePacketCount' */
	uint8_t RemoteSentHandshakePacketCount;

	/** Whether or not this packet is a restart handshake packet */
	uint8_t bRestartHandshake;

	/** Which of the two serverside HandshakeSecret values this is based on */
	uint8_t SecretId;

	/** The server timestamp, from the moment the challenge was sent (or 0.f if from the client) */
	double Timestamp;

	/** A unique identifier, generated by the server, which the client must reply with (or 0, for initial packet) */
	uint8_t Cookie[COOKIE_BYTE_SIZE];

	/** If this is a restart handshake challenge response, this is the original handshake's cookie */
	uint8_t OrigCookie[COOKIE_BYTE_SIZE];
};

static uint8_t CachedGlobalNetTravelCount()
{
	struct utcp_config* utcp_config = utcp_get_config();
	uint32_t CachedGlobalNetTravelCount = utcp_config->GlobalNetTravelCount;
	CachedGlobalNetTravelCount = CachedGlobalNetTravelCount & ((1 << SessionIDSizeBits) - 1);
	return CachedGlobalNetTravelCount;
}

void ParsedHandshakeDataInit(struct FParsedHandshakeData* OutResult)
{
	memset(OutResult, 0, sizeof(*OutResult));
	OutResult->RemoteMinVersion = EHandshakeVersion_Latest;
	OutResult->RemoteCurVersion = EHandshakeVersion_Latest;
}

static inline int32_t GetAdjustedSizeBits(int32_t InSizeBits, uint8_t InHandshakeVersion)
{
	struct utcp_config* utcp_config = utcp_get_config();
	int32_t ReturnVal = utcp_config->MagicHeaderBits + InSizeBits;
	if (InHandshakeVersion >= EHandshakeVersion_SessionClientId)
	{
		ReturnVal += SessionIDSizeBits + ClientIDSizeBits;
	}
	return ReturnVal;
}

// StatelessConnectHandlerComponent::GenerateCookie
extern void sha1_hmac_buffer(const void* Key, uint32_t KeySize, const void* Data, uint64_t DataSize, uint8_t* OutHash);
static void GenerateCookie(struct utcp_listener* fd, const char* ClientAddress, uint8_t SecretId, double Timestamp, uint8_t* OutCookie)
{
	size_t ClientAddressLen = strlen(ClientAddress);
	uint8_t CookieData[sizeof(double) + sizeof(int32_t) + ADDRSTR_PORT_SIZE];
	size_t Offset = 0;

	memcpy(CookieData + Offset, &Timestamp, sizeof(Timestamp));
	Offset += sizeof(Timestamp);
	memcpy(CookieData + Offset, &ClientAddressLen, sizeof(ClientAddressLen));
	Offset += sizeof(ClientAddressLen);
	memcpy(CookieData + Offset, ClientAddress, ClientAddressLen);
	Offset += ClientAddressLen;

	sha1_hmac_buffer(fd->HandshakeSecret[!!SecretId], SECRET_BYTE_SIZE, CookieData, Offset, OutCookie);
}

// StatelessConnectHandlerComponent::CapHandshakePacket
static void CapHandshakePacket(struct utcp_challenge_data* challenge_data, struct bitbuf* bitbuf, uint8_t HandshakeVersion)
{
	size_t NumBits = bitbuf->num - GetAdjustedSizeBits(0, HandshakeVersion);
	if (HandshakeVersion == EHandshakeVersion_Original)
	{
		assert(NumBits == OriginalHandshakePacketSizeBits || NumBits == OriginalRestartHandshakePacketSizeBits || NumBits == OriginalRestartResponseSizeBits);
	}
	else if (HandshakeVersion == EHandshakeVersion_Randomized)
	{
		assert(NumBits == VerRandomizedHandshakePacketSizeBits || NumBits == VerRandomizedRestartHandshakePacketSizeBits || NumBits == VerRandomizedRestartResponseSizeBits);
	}
	else
	{
		assert(NumBits == HANDSHAKE_PACKET_SIZE_BITS || NumBits == RESTART_HANDSHAKE_PACKET_SIZE_BITS || NumBits == RESTART_RESPONSE_SIZE_BITS);
	}

	if (HandshakeVersion >= EHandshakeVersion_Randomized)
	{
		int32_t RandomDataLengthBytes = BaseRandomDataLengthBytes - utcp_rand() % RandomDataLengthVarianceBytes;
		if (HandshakeVersion < EHandshakeVersion_SessionClientId)
		{
			if (NumBits + (RandomDataLengthBytes * 8) == OriginalRestartResponseSizeBits)
			{
				RandomDataLengthBytes = RandomDataLengthBytes - 1;
				RandomDataLengthBytes = RandomDataLengthBytes > 0 ? RandomDataLengthBytes : 0;
			}
		}
		for (int32_t RandIdx = 0; RandIdx < RandomDataLengthBytes; RandIdx++)
		{
			uint8_t RandVal = utcp_rand() % 255;
			bitbuf_read_bytes(bitbuf, &RandVal, sizeof(RandVal));
		}
	}

	// Add a termination bit, the same as the UNetConnection code does
	bitbuf_write_end(bitbuf);

	if (challenge_data)
	{
		challenge_data->SentHandshakePacketCount++;
	}
}

static void WriteHandshakeVersion(struct bitbuf* bitbuf, uint8_t HandshakePacketType, uint8_t HandshakeVersion, uint8_t ClientSentHandshakePacketCount,
								  uint32_t LocalNetworkVersion)
{
	if (HandshakeVersion >= EHandshakeVersion_Randomized)
	{
		uint8_t MinVersion = EHandshakeVersion_Randomized;
		uint8_t CurVersion = HandshakeVersion;
		bitbuf_write_bytes(bitbuf, &MinVersion, sizeof(MinVersion));
		bitbuf_write_bytes(bitbuf, &CurVersion, sizeof(CurVersion));
		bitbuf_write_bytes(bitbuf, &HandshakePacketType, sizeof(HandshakePacketType));
		bitbuf_write_bytes(bitbuf, &ClientSentHandshakePacketCount, sizeof(ClientSentHandshakePacketCount));
	}

	if (HandshakeVersion >= EHandshakeVersion_NetCLVersion)
	{
		bitbuf_write_bytes(bitbuf, &LocalNetworkVersion, sizeof(LocalNetworkVersion));
	}
}

// StatelessConnectHandlerComponent::SendConnectChallenge
static void SendConnectChallenge(struct utcp_listener* fd, const char* address, uint8_t HandshakeVersion, uint8_t ClientSentHandshakePacketCount, uint32_t InClientID,
								 uint32_t LocalNetworkVersion)
{
	// GetAdjustedSizeBits(HANDSHAKE_PACKET_SIZE_BITS) + 1 /* Termination bit */
	uint8_t buffer[UTCP_MAX_PACKET];
	struct bitbuf bitbuf;
	if (!bitbuf_write_init(&bitbuf, buffer, sizeof(buffer)))
		return;

	uint8_t bHandshakePacket = 1;
	uint8_t bRestartHandshake = 0; // Ignored clientside
	double Timestamp = utcp_gettime();
	uint8_t Cookie[COOKIE_BYTE_SIZE];

	GenerateCookie(fd, address, fd->ActiveSecret, Timestamp, Cookie);

	write_packet_header(&bitbuf, HandshakeVersion, CachedGlobalNetTravelCount(), InClientID, bHandshakePacket);
	bitbuf_write_bit(&bitbuf, bRestartHandshake);

	WriteHandshakeVersion(&bitbuf, EHandshakePacketType_Challenge, HandshakeVersion, ClientSentHandshakePacketCount, LocalNetworkVersion);

	bitbuf_write_bit(&bitbuf, fd->ActiveSecret);
	bitbuf_write_bytes(&bitbuf, &Timestamp, sizeof(Timestamp));
	bitbuf_write_bytes(&bitbuf, Cookie, sizeof(Cookie));

	CapHandshakePacket(NULL, &bitbuf, HandshakeVersion);

	utcp_listener_outgoing(fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));
}

// StatelessConnectHandlerComponent::SendRestartHandshakeRequest
static void SendRestartHandshakeRequest(struct utcp_listener* fd, uint8_t HandshakeVersion, uint8_t ClientSentHandshakePacketCount, uint32_t InClientID,
										uint32_t LocalNetworkVersion)
{
	// GetAdjustedSizeBits(RESTART_HANDSHAKE_PACKET_SIZE_BITS) + 1 /* Termination bit */
	uint8_t buffer[UTCP_MAX_PACKET];
	struct bitbuf bitbuf;
	if (!bitbuf_write_init(&bitbuf, buffer, sizeof(buffer)))
		return;

	uint8_t bHandshakePacket = 1;
	uint8_t bRestartHandshake = 1;

	write_packet_header(&bitbuf, HandshakeVersion, CachedGlobalNetTravelCount(), InClientID, bHandshakePacket);
	bitbuf_write_bit(&bitbuf, bRestartHandshake);

	WriteHandshakeVersion(&bitbuf, EHandshakePacketType_Challenge, HandshakeVersion, ClientSentHandshakePacketCount, LocalNetworkVersion);

	CapHandshakePacket(NULL, &bitbuf, HandshakeVersion);

	utcp_listener_outgoing(fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));
}

// StatelessConnectHandlerComponent::SendChallengeAck
static void SendChallengeAck(struct utcp_listener* listener_fd, struct utcp_connection* fd, uint8_t InCookie[COOKIE_BYTE_SIZE], uint8_t HandshakeVersion,
							 uint8_t ClientSentHandshakePacketCount, uint32_t InClientID, uint32_t LocalNetworkVersion)
{
	// GetAdjustedSizeBits(HANDSHAKE_PACKET_SIZE_BITS) + 1 /* Termination bit */
	uint8_t buffer[UTCP_MAX_PACKET];
	struct bitbuf bitbuf;
	if (!bitbuf_write_init(&bitbuf, buffer, sizeof(buffer)))
		return;

	uint8_t bHandshakePacket = 1;
	uint8_t bRestartHandshake = 0; // Ignored clientside
	double Timestamp = -1.0;

	write_packet_header(&bitbuf, HandshakeVersion, CachedGlobalNetTravelCount(), InClientID, bHandshakePacket);
	bitbuf_write_bit(&bitbuf, bRestartHandshake);

	WriteHandshakeVersion(&bitbuf, EHandshakePacketType_Ack, HandshakeVersion, ClientSentHandshakePacketCount, LocalNetworkVersion);

	bitbuf_write_bit(&bitbuf, bHandshakePacket); // ActiveSecret

	bitbuf_write_bytes(&bitbuf, &Timestamp, sizeof(Timestamp));
	bitbuf_write_bytes(&bitbuf, InCookie, COOKIE_BYTE_SIZE);

	if (listener_fd)
	{
		CapHandshakePacket(NULL, &bitbuf, HandshakeVersion);
		utcp_listener_outgoing(listener_fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));
	}
	else
	{
		CapHandshakePacket(fd->challenge_data, &bitbuf, HandshakeVersion);
		utcp_connection_outgoing(fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));
	}
}

// StatelessConnectHandlerComponent::ParseHandshakePacketOriginal
static bool ParseHandshakePacketOriginal(struct bitbuf* bitbuf, bool bIsClient, struct FParsedHandshakeData* OutResult)
{
	bool bValidPacket = false;
	size_t BitsLeft = bitbuf->size - bitbuf->num;
	bool bHandshakePacketSize = BitsLeft == (OriginalHandshakePacketSizeBits - 1);
	bool bRestartResponsePacketSize = BitsLeft == (OriginalRestartResponseSizeBits - 1);

	OutResult->RemoteMinVersion = EHandshakeVersion_Original;
	OutResult->RemoteCurVersion = EHandshakeVersion_Original;

	// Only accept handshake packets of precisely the right size
	if (bHandshakePacketSize || bRestartResponsePacketSize)
	{
		if (!bitbuf_read_bit(bitbuf, &OutResult->bRestartHandshake))
			return false;

		if (!bitbuf_read_bit(bitbuf, &OutResult->SecretId))
			return false;

		if (!bitbuf_read_bytes(bitbuf, &OutResult->Timestamp, sizeof(OutResult->Timestamp)))
			return false;

		if (!bitbuf_read_bytes(bitbuf, OutResult->Cookie, sizeof(OutResult->Cookie)))
			return false;

		if (bRestartResponsePacketSize)
		{
			if (!bitbuf_read_bytes(bitbuf, OutResult->OrigCookie, sizeof(OutResult->Cookie)))
				return false;
		}
		else if (OutResult->Timestamp > 0.0)
		{
			if (bIsClient)
			{
				OutResult->HandshakePacketType = EHandshakePacketType_Challenge;
			}
			else
			{
				OutResult->HandshakePacketType = EHandshakePacketType_Response;
			}
		}
		else if (OutResult->Timestamp < 0.0)
		{
			OutResult->HandshakePacketType = EHandshakePacketType_Ack;
		}
		else
		{
			OutResult->HandshakePacketType = EHandshakePacketType_InitialPacket;
		}
		bValidPacket = true;
	}
	else if (BitsLeft == (OriginalRestartHandshakePacketSizeBits - 1))
	{
		OutResult->HandshakePacketType = EHandshakePacketType_RestartHandshake;
		if (!bitbuf_read_bit(bitbuf, &OutResult->bRestartHandshake))
			return false;
		bValidPacket = OutResult->bRestartHandshake && bIsClient;
	}

	return bValidPacket;
}

// StatelessConnectHandlerComponent::ParseHandshakePacket
static bool ParseHandshakePacket(struct bitbuf* bitbuf, bool bIsClient, struct FParsedHandshakeData* OutResult)
{
	bool bValidPacket = false;
	int32_t BitsLeft = (int32_t)(bitbuf->size - bitbuf->num);

	if (MinSupportedHandshakeVersion() == EHandshakeVersion_Original)
	{
		bool bOriginalVersion =
			BitsLeft == (OriginalHandshakePacketSizeBits - 1) || BitsLeft == (OriginalRestartHandshakePacketSizeBits - 1) || BitsLeft == (OriginalRestartResponseSizeBits - 1);
		if (bOriginalVersion)
		{
			return ParseHandshakePacketOriginal(bitbuf, bIsClient, OutResult);
		}
	}

	// Remaining bits, excluding packet sizes from different protocol versions
	const int32_t MinBitsLeftExclHandshake = BitsLeft - (HANDSHAKE_PACKET_SIZE_BITS - 1);
	const int32_t MaxBitsLeftExclHandshake = BitsLeft - (VerRandomizedHandshakePacketSizeBits - 1);
	const int32_t MinBitsLeftExclRestartHandshake = BitsLeft - (RESTART_HANDSHAKE_PACKET_SIZE_BITS - 1);
	const int32_t MaxBitsLeftExclRestartHandshake = BitsLeft - (VerRandomizedRestartHandshakePacketSizeBits - 1);
	const int32_t MinBitsLeftExclRestartResponse = BitsLeft - (RESTART_RESPONSE_SIZE_BITS - 1);
	const int32_t MaxBitsLeftExclRestartResponse = BitsLeft - (VerRandomizedRestartResponseSizeBits - 1);
	const int32_t MinRandomBits = (BaseRandomDataLengthBytes - RandomDataLengthVarianceBytes) * 8;
	const int32_t MaxRandomBits = BaseRandomDataLengthBytes * 8;
	const bool bMaybeHandshakePacket = MaxBitsLeftExclHandshake >= MinRandomBits && MinBitsLeftExclHandshake <= MaxRandomBits;
	const bool bMaybeRestartHandshakePacket = MaxBitsLeftExclRestartHandshake >= MinRandomBits && MinBitsLeftExclRestartHandshake <= MaxRandomBits;
	const bool bMaybeRestartResponsePacket = MaxBitsLeftExclRestartResponse >= MinRandomBits && MinBitsLeftExclRestartResponse <= MaxRandomBits;

	if (!bitbuf_read_bit(bitbuf, &OutResult->bRestartHandshake))
		return false;

	if (!bitbuf_read_bytes(bitbuf, &OutResult->RemoteMinVersion, sizeof(OutResult->RemoteMinVersion)))
		return false;

	if (!bitbuf_read_bytes(bitbuf, &OutResult->RemoteCurVersion, sizeof(OutResult->RemoteCurVersion)))
		return false;

	if (!bitbuf_read_bytes(bitbuf, &OutResult->HandshakePacketType, sizeof(OutResult->HandshakePacketType)))
		return false;

	if (!bitbuf_read_bytes(bitbuf, &OutResult->RemoteSentHandshakePacketCount, sizeof(OutResult->RemoteSentHandshakePacketCount)))
		return false;

	if (OutResult->RemoteCurVersion >= EHandshakeVersion_NetCLVersion)
	{
		if (!bitbuf_read_bytes(bitbuf, &OutResult->RemoteNetworkVersion, sizeof(OutResult->RemoteNetworkVersion)))
			return false;
	}

	// Only accept handshake packets of roughly the right size
	const bool bHandshakePacket =
		bMaybeHandshakePacket && (OutResult->HandshakePacketType == EHandshakePacketType_InitialPacket || OutResult->HandshakePacketType == EHandshakePacketType_Challenge ||
								  OutResult->HandshakePacketType == EHandshakePacketType_Response || OutResult->HandshakePacketType == EHandshakePacketType_Ack);

	const bool bRestartHandshakePacket = bMaybeRestartHandshakePacket && OutResult->HandshakePacketType == EHandshakePacketType_RestartHandshake;
	const bool bRestartResponsePacket = bMaybeRestartResponsePacket && OutResult->HandshakePacketType == EHandshakePacketType_RestartResponse;

	// Only accept handshake packets of precisely the right size
	if (bHandshakePacket || bRestartResponsePacket)
	{
		if (!bitbuf_read_bit(bitbuf, &OutResult->SecretId))
			return false;

		if (!bitbuf_read_bytes(bitbuf, &OutResult->Timestamp, sizeof(OutResult->Timestamp)))
			return false;

		if (!bitbuf_read_bytes(bitbuf, OutResult->Cookie, sizeof(OutResult->Cookie)))
			return false;

		if (bRestartResponsePacket)
		{
			if (!bitbuf_read_bytes(bitbuf, OutResult->OrigCookie, sizeof(OutResult->OrigCookie)))
				return false;
		}

		bValidPacket = true;
	}
	else if (bRestartHandshakePacket)
	{
		bValidPacket = OutResult->bRestartHandshake && bIsClient;
	}

	if (bValidPacket)
	{
		bitbuf->num = bitbuf->size;
	}

	return bValidPacket;
}

// StatelessConnectHandlerComponent::IncomingConnectionless
static int IncomingConnectionless(struct utcp_listener* fd, const char* address, struct bitbuf* bitbuf)
{
	uint8_t SessionID, ClientID, bHandshakePacket;
	if (!read_packet_header(bitbuf, LastRemoteHandshakeVersion(), &SessionID, &ClientID, &bHandshakePacket))
		return -2;

	if (!bHandshakePacket)
	{
		SendRestartHandshakeRequest(fd, EHandshakeVersion_Original, 0, 0, 0);
		return -3;
	}

	struct FParsedHandshakeData HandshakeData;
	ParsedHandshakeDataInit(&HandshakeData);

	bHandshakePacket = ParseHandshakePacket(bitbuf, false, &HandshakeData);
	if (!bHandshakePacket)
	{
		return -4;
	}

	bool bInitialConnect = HandshakeData.HandshakePacketType == EHandshakePacketType_InitialPacket && HandshakeData.Timestamp == 0.0;
	if (bInitialConnect)
	{
		SendConnectChallenge(fd, address, HandshakeData.RemoteCurVersion, HandshakeData.RemoteSentHandshakePacketCount, ClientID, HandshakeData.RemoteNetworkVersion);
		return 0;
	}
	// NOTE: Allow CookieDelta to be 0.0, as it is possible for a server to send a challenge and receive a response,
	//			during the same tick
	bool bChallengeSuccess = false;
	const double CookieDelta = utcp_gettime() - HandshakeData.Timestamp;
	const double SecretDelta = HandshakeData.Timestamp - fd->LastSecretUpdateTimestamp;
	const bool bValidCookieLifetime = CookieDelta >= 0.0 && (MAX_COOKIE_LIFETIME - CookieDelta) > 0.0;
	const bool bValidSecretIdTimestamp = (HandshakeData.SecretId == fd->ActiveSecret) ? (SecretDelta >= 0.0) : (SecretDelta <= 0.0);

	if (bValidCookieLifetime && bValidSecretIdTimestamp)
	{
		// Regenerate the cookie from the packet info, and see if the received cookie matches the regenerated one
		uint8_t RegenCookie[COOKIE_BYTE_SIZE];

		GenerateCookie(fd, address, HandshakeData.SecretId, HandshakeData.Timestamp, RegenCookie);

		bChallengeSuccess = memcmp(HandshakeData.Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0;

		if (bChallengeSuccess)
		{
			if (HandshakeData.bRestartHandshake)
			{
				memcpy(fd->AuthorisedCookie, HandshakeData.OrigCookie, sizeof(fd->AuthorisedCookie));
			}
			else
			{
				int16_t* CurSequence = (int16_t*)HandshakeData.Cookie;

				fd->LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
				fd->LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

				memcpy(fd->AuthorisedCookie, HandshakeData.Cookie, sizeof(fd->AuthorisedCookie));
			}

			fd->bRestartedHandshake = HandshakeData.bRestartHandshake;
			strncpy(fd->LastChallengeSuccessAddress, address, sizeof(fd->LastChallengeSuccessAddress));

			// Now ack the challenge response - the cookie is stored in AuthorisedCookie, to enable retries
			SendChallengeAck(fd, NULL, fd->AuthorisedCookie, HandshakeData.RemoteCurVersion, HandshakeData.RemoteSentHandshakePacketCount, ClientID,
							 HandshakeData.RemoteNetworkVersion);
			return 0;
		}
		return -7;
	}
	return -6;
}

// StatelessConnectHandlerComponent::HasPassedChallenge
static bool HasPassedChallenge(struct utcp_listener* fd, const char* address, bool* bOutRestartedHandshake)
{
	*bOutRestartedHandshake = fd->bRestartedHandshake;
	return strncmp(fd->LastChallengeSuccessAddress, address, sizeof(fd->LastChallengeSuccessAddress)) == 0;
}

// StatelessConnectHandlerComponent::ResetChallengeData
static void ResetChallengeData(struct utcp_listener* fd)
{
	fd->LastChallengeSuccessAddress[0] = '\0';
	fd->bRestartedHandshake = false;
	fd->LastServerSequence = 0;
	fd->LastClientSequence = 0;
	memset(fd->AuthorisedCookie, 0, COOKIE_BYTE_SIZE);
}

// UIpNetDriver::ProcessConnectionlessPacket
int process_connectionless_packet(struct utcp_listener* fd, const char* address, const uint8_t* buffer, int len)
{
	struct bitbuf bitbuf;
	if (!bitbuf_read_init(&bitbuf, buffer, len))
	{
		return -1;
	}

	int ret = IncomingConnectionless(fd, address, &bitbuf);
	if (ret)
	{
		return ret;
	}

	assert(bitbuf.num == bitbuf.size);

	bool bPassedChallenge = false;
	bool bRestartedHandshake = false;
	// bool bIgnorePacket = true;

	bPassedChallenge = HasPassedChallenge(fd, address, &bRestartedHandshake);
	if (bPassedChallenge)
	{
		if (bRestartedHandshake)
		{
			utcp_on_accept(fd, true);
		}

		// bIgnorePacket = false
	}
	if (bPassedChallenge)
	{
		if (!bRestartedHandshake)
		{
			utcp_on_accept(fd, false);
		}
		ResetChallengeData(fd);
	}
	return 0;
}

// StatelessConnectHandlerComponent::SendInitialPacket
static void SendInitialPacket(struct utcp_connection* fd, uint8_t HandshakeVersion)
{
	if (!is_client(fd))
		return;

	// GetAdjustedSizeBits(fd, HANDSHAKE_PACKET_SIZE_BITS) + 1
	uint8_t buffer[UTCP_MAX_PACKET];
	struct bitbuf bitbuf;
	if (!bitbuf_write_init(&bitbuf, buffer, sizeof(buffer)))
		return;

	uint8_t bHandshakePacket = 1;
	write_packet_header(&bitbuf, HandshakeVersion, fd->challenge_data->CachedGlobalNetTravelCount, fd->challenge_data->CachedClientID, bHandshakePacket);

	// In order to prevent DRDoS reflection amplification attacks, clients must pad the packet to match server packet size
	uint8_t bRestartHandshake = fd->challenge_data->bRestartedHandshake ? 1 : 0;
	uint8_t SecretIdPad = 0;
	uint8_t PacketSizeFiller[28];

	bitbuf_write_bit(&bitbuf, bRestartHandshake);

	{
		struct utcp_config* utcp_config = utcp_get_config();
		WriteHandshakeVersion(&bitbuf, EHandshakePacketType_InitialPacket, HandshakeVersion, fd->challenge_data->SentHandshakePacketCount, utcp_config->CachedNetworkChecksum);
	}

	bitbuf_write_bit(&bitbuf, SecretIdPad);

	memset(PacketSizeFiller, 0, sizeof(PacketSizeFiller));
	bitbuf_write_bytes(&bitbuf, PacketSizeFiller, sizeof(PacketSizeFiller));

	CapHandshakePacket(fd->challenge_data, &bitbuf, HandshakeVersion);

	utcp_connection_outgoing(fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));
	fd->challenge_data->LastClientSendTimestamp = utcp_gettime_ms();
}

void handshake_begin(struct utcp_connection* fd)
{
	assert(!fd->challenge_data);
	fd->challenge_data = (struct utcp_challenge_data*)utcp_realloc(NULL, sizeof(*fd->challenge_data));
	memset(fd->challenge_data, 0, sizeof(sizeof(*fd->challenge_data)));
	fd->challenge_data->bBeganHandshaking = true;

	static int32_t CachedClientID = 0;
	CachedClientID = CachedClientID > 0 ? CachedClientID : 0;
	CachedClientID++;
	fd->challenge_data->CachedClientID = CachedClientID & (1 << ClientIDSizeBits) - 1;

	SendInitialPacket(fd, CurrentHandshakeVersion());
}

// StatelessConnectHandlerComponent::SendChallengeResponse
static void SendChallengeResponse(struct utcp_connection* fd, uint8_t InSecretId, double InTimestamp, uint8_t InCookie[COOKIE_BYTE_SIZE], uint8_t HandshakeVersion)
{
	// int32_t RestartHandshakeResponseSize = RESTART_RESPONSE_SIZE_BITS;
	// const int32 BaseSize = GetAdjustedSizeBits(fd->bRestartedHandshake ? RestartHandshakeResponseSize : HANDSHAKE_PACKET_SIZE_BITS);
	// BaseSize + 1 /* Termination bit */
	uint8_t buffer[UTCP_MAX_PACKET];
	struct bitbuf bitbuf;
	if (!bitbuf_write_init(&bitbuf, buffer, sizeof(buffer)))
		return;

	uint8_t bHandshakePacket = 1;
	uint8_t bRestartHandshake = (fd->challenge_data->bRestartedHandshake ? 1 : 0);

	write_packet_header(&bitbuf, HandshakeVersion, fd->challenge_data->CachedGlobalNetTravelCount, fd->challenge_data->CachedClientID, bHandshakePacket);

	bitbuf_write_bit(&bitbuf, bRestartHandshake);

	{
		struct utcp_config* utcp_config = utcp_get_config();
		uint8_t HandshakePacketType = bRestartHandshake ? EHandshakePacketType_RestartResponse : EHandshakePacketType_Response;
		WriteHandshakeVersion(&bitbuf, HandshakePacketType, HandshakeVersion, fd->challenge_data->SentHandshakePacketCount, utcp_config->CachedNetworkChecksum);
	}

	bitbuf_write_bit(&bitbuf, InSecretId);

	bitbuf_write_bytes(&bitbuf, &InTimestamp, sizeof(InTimestamp));
	bitbuf_write_bytes(&bitbuf, InCookie, COOKIE_BYTE_SIZE);

	if (fd->challenge_data->bRestartedHandshake)
	{
		bitbuf_write_bytes(&bitbuf, fd->AuthorisedCookie, COOKIE_BYTE_SIZE);
	}

	CapHandshakePacket(fd->challenge_data, &bitbuf, HandshakeVersion);
	utcp_connection_outgoing(fd, bitbuf.buffer, bitbuf_num_bytes(&bitbuf));

	fd->challenge_data->LastClientSendTimestamp = utcp_gettime_ms();
	fd->challenge_data->LastSecretId = InSecretId;
	fd->challenge_data->LastTimestamp = InTimestamp;

	memcpy(fd->challenge_data->LastCookie, InCookie, sizeof(fd->AuthorisedCookie));
}

// HandlerComponent::SetState
static void SetState(struct utcp_connection* fd, enum utcp_challenge_state state)
{
	fd->challenge_data->state = state;
}

// void StatelessConnectHandlerComponent::Incoming(FBitReader& Packet)
int handshake_incoming(struct utcp_connection* fd, struct bitbuf* bitbuf)
{
	bool bHasValidSessionID = true;
	bool bHasValidClientID = true;

	uint8_t SessionID, ClientID, bHandshakePacket;
	if (!read_packet_header(bitbuf, LastRemoteHandshakeVersion(), &SessionID, &ClientID, &bHandshakePacket))
		return -1;

	if (!bHandshakePacket)
	{
		fd->LastSessionID = SessionID;
		fd->LastClientID = ClientID;
		return 0;
	}

	struct FParsedHandshakeData HandshakeData;
	ParsedHandshakeDataInit(&HandshakeData);

	bHandshakePacket = ParseHandshakePacket(bitbuf, false, &HandshakeData);
	if (!bHandshakePacket)
	{
		return -2;
	}

	if (!is_client(fd))
	{
		// TODO
		// Servers should wipe LastChallengeSuccessAddress shortly after the first non-handshake packet is received by the client,
		// in order to disable challenge ack resending

		// The server should not be receiving handshake packets at this stage - resend the ack in case it was lost.
		// In this codepath, this component is linked to a UNetConnection, and the Last* values below, cache the handshake info.
		SendChallengeAck(NULL, fd, fd->AuthorisedCookie, EHandshakeVersion_Original, 0, 0, 0);

		return 0;
	}

	const bool bIsChallengePacket = HandshakeData.HandshakePacketType == EHandshakePacketType_Challenge && HandshakeData.Timestamp > 0.0;
	const bool bIsInitialChallengePacket = bIsChallengePacket && fd->challenge_data->state != Initialized;

	if (!(bHasValidClientID && (bHasValidSessionID || bIsInitialChallengePacket)))
		return -9;

	if (fd->challenge_data->state == UnInitialized || fd->challenge_data->state == InitializedOnLocal)
	{
		if (HandshakeData.bRestartHandshake)
		{
			utcp_log(Log, "Ignoring restart handshake request, while already restarted.");
		}
		// Receiving challenge, verify the timestamp is > 0.0f
		else if (bIsChallengePacket)
		{
			fd->challenge_data->LastChallengeTimestamp = utcp_gettime_ms();

			SendChallengeResponse(fd, HandshakeData.SecretId, HandshakeData.Timestamp, HandshakeData.Cookie, LastRemoteHandshakeVersion());

			// Utilize this state as an intermediary, indicating that the challenge response has been sent
			SetState(fd, InitializedOnLocal);
		}
		// Receiving challenge ack, verify the timestamp is < 0.0f
		else if (HandshakeData.HandshakePacketType == EHandshakePacketType_Ack && HandshakeData.Timestamp < 0.0)
		{
			if (!fd->challenge_data->bRestartedHandshake)
			{
				// Extract the initial packet sequence from the random Cookie data
				int16_t* CurSequence = (int16_t*)HandshakeData.Cookie;
				int32_t LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
				int32_t LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

				utcp_sequence_init(fd, LastServerSequence, LastClientSequence);
				// Save the final authorized cookie
				memcpy(fd->AuthorisedCookie, HandshakeData.Cookie, sizeof(fd->AuthorisedCookie));
			}

			// Now finish initializing the handler - flushing the queued packet buffer in the process.
			SetState(fd, Initialized);
			utcp_on_connect(fd, fd->challenge_data->bRestartedHandshake);
			fd->challenge_data->bRestartedHandshake = false;
		}
	}
	else if (HandshakeData.bRestartHandshake)
	{
		uint8_t ZeroCookie[COOKIE_BYTE_SIZE] = {0};
		bool bValidAuthCookie = memcmp(fd->AuthorisedCookie, ZeroCookie, COOKIE_BYTE_SIZE) != 0;

		// The server has requested us to restart the handshake process - this is because
		// it has received traffic from us on a different address than before.
		if (bValidAuthCookie)
		{
			bool bPassedDelayCheck = false;
			bool bPassedDualIPCheck = false;
			int64_t CurrentTime = utcp_gettime_ms();

			if (!fd->challenge_data->bRestartedHandshake)
			{
				// The server may send multiple restart handshake packets, so have a 10 second delay between accepting them
				bPassedDelayCheck = (CurrentTime - fd->challenge_data->LastClientSendTimestamp) > 10 * 1000;

				// Some clients end up sending packets duplicated over multiple IP's, triggering the restart handshake.
				// Detect this by checking if any restart handshake requests have been received in roughly the last second
				// (Dual IP situations will make the server send them constantly) - and override the checks as a failsafe,
				// if no NetConnection packets have been received in the last second.
				int64_t LastRestartPacketTimeDiff = CurrentTime - fd->challenge_data->LastRestartPacketTimestamp;
				int64_t LastNetConnPacketTimeDiff = CurrentTime - fd->LastReceiveRealtime;

				bPassedDualIPCheck = fd->challenge_data->LastRestartPacketTimestamp == 0 || LastRestartPacketTimeDiff > 1100 || LastNetConnPacketTimeDiff > 1000;
			}

			fd->challenge_data->LastRestartPacketTimestamp = CurrentTime;
			if (!fd->challenge_data->bRestartedHandshake && bPassedDelayCheck && bPassedDualIPCheck)
			{
				// UE_LOG(LogHandshake, Log, TEXT("Beginning restart handshake process."));

				fd->challenge_data->bRestartedHandshake = true;
				SetState(fd, UnInitialized);
				SendInitialPacket(fd, LastRemoteHandshakeVersion());
			}
			else
			{
				if (fd->challenge_data->bRestartedHandshake)
				{
					utcp_log(Log, "Ignoring restart handshake request, while already restarted (this is normal).");
				}
			}
		}
		else
		{
			utcp_log(Log, "Server sent restart handshake request, when we don't have an authorised cookie.");
			return -3;
		}
	}
	else
	{
		// Ignore, could be a dupe/out-of-order challenge packet
	}

	return 0;
}

// StatelessConnectHandlerComponent::Tick
void handshake_update(struct utcp_connection* fd)
{
	if (fd->challenge_data == NULL || fd->challenge_data->LastClientSendTimestamp == 0)
	{
		return;
	}

	int64_t now = utcp_gettime_ms();
	int64_t LastSendTimeDiff = now - fd->challenge_data->LastClientSendTimestamp;
	if (LastSendTimeDiff < 1000)
	{
		return;
	}

	const bool bRestartChallenge = now - fd->challenge_data->LastChallengeTimestamp > MIN_COOKIE_LIFETIME * 1000;
	if (bRestartChallenge)
	{
		SetState(fd, UnInitialized);
	}

	if (fd->challenge_data->state == UnInitialized)
	{
		SendInitialPacket(fd, LastRemoteHandshakeVersion());
	}
	else if (fd->challenge_data->state == InitializedOnLocal && fd->challenge_data->LastTimestamp != 0.0)
	{
		SendChallengeResponse(fd, fd->challenge_data->LastSecretId, fd->challenge_data->LastTimestamp, fd->challenge_data->LastCookie, LastRemoteHandshakeVersion());
	}
}

bool is_client(struct utcp_connection* fd)
{
	return fd->challenge_data != NULL;
}

bool is_connected(struct utcp_connection* fd)
{
	return !is_client(fd) || (is_client(fd) && fd->challenge_data->state == Initialized);
}

static bool write_magic_header(struct bitbuf* bitbuf)
{
	struct utcp_config* utcp_config = utcp_get_config();
	if (utcp_config->MagicHeaderBits == 0)
		return true;
	return bitbuf_write_bits(bitbuf, &utcp_config->MagicHeader, utcp_config->MagicHeaderBits);
}

static bool read_magic_header(struct bitbuf* bitbuf)
{
	struct utcp_config* utcp_config = utcp_get_config();
	if (utcp_config->MagicHeaderBits == 0)
		return true;
	uint32_t MagicHeader;
	if (!bitbuf_read_bits(bitbuf, &MagicHeader, utcp_config->MagicHeaderBits))
		return false;
	return MagicHeader == utcp_config->MagicHeader;
}

bool write_packet_header(struct bitbuf* bitbuf, uint8_t handshake_version, uint8_t session_id, uint8_t client_id, uint8_t is_handshake)
{
	assert(bitbuf->num == 0);
	if (bitbuf->num != 0)
		return false;

	if (!write_magic_header(bitbuf))
		return false;

	if (handshake_version >= EHandshakeVersion_SessionClientId)
	{
		if (!bitbuf_write_bits(bitbuf, &session_id, SessionIDSizeBits))
			return false;
		if (!bitbuf_write_bits(bitbuf, &client_id, ClientIDSizeBits))
			return false;
	}
	if (!bitbuf_write_bit(bitbuf, is_handshake))
		return false;
	return true;
}

bool read_packet_header(struct bitbuf* bitbuf, uint8_t handshake_version, uint8_t* session_id, uint8_t* client_id, uint8_t* is_handshake)
{
	assert(bitbuf->num == 0);
	if (bitbuf->num != 0)
		return false;

	if (!read_magic_header(bitbuf))
		return false;

	if (handshake_version >= EHandshakeVersion_SessionClientId)
	{
		if (!bitbuf_read_bits(bitbuf, session_id, SessionIDSizeBits))
			return false;
		if (!bitbuf_read_bits(bitbuf, client_id, ClientIDSizeBits))
			return false;
	}

	if (!bitbuf_read_bit(bitbuf, is_handshake))
		return false;
	return true;
}

uint8_t LastRemoteHandshakeVersion()
{
	return LastRemoteHandshakeVersionVar;
}

uint8_t CurrentHandshakeVersion()
{
	return CurrentHandshakeVersionVar;
}

uint8_t MinSupportedHandshakeVersion()
{
	return MinSupportedHandshakeVersionVar;
}
